[{"title":"C++ Primer 第十二章练习题","url":"http://eiwzz.github.io/2016/11/07/C-Primer-第十二章练习题/","content":"<h2 id=\"12-1-1节练习\"><a href=\"#12-1-1节练习\" class=\"headerlink\" title=\"12.1.1节练习\"></a>12.1.1节练习</h2><h3 id=\"练习-12-1\"><a href=\"#练习-12-1\" class=\"headerlink\" title=\"练习 12.1　　\"></a>练习 12.1　　</h3><blockquote>\n<p>在此代码的结尾，b1和b2各包含多少个元素？<br>StrBlob b1;<br>{<br>    StrBlob b2 = {“a”,”an”,”the”};<br>    b1 = b2;<br>    b2.push_back(“about”);<br>}</p>\n</blockquote>\n<a id=\"more\"></a> \n<p><strong>b2</strong>有４个元素。<br><strong>b1</strong>被自动销毁，说包含几个元素就没意义了。</p>\n<h3 id=\"练习-12-2\"><a href=\"#练习-12-2\" class=\"headerlink\" title=\"练习 12.2\"></a>练习 12.2</h3><blockquote>\n<p>编写你自己的StrBlob类，包含const版本的front和back。</p>\n</blockquote>\n<p>　　<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;initializer_list&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;exception&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"keyword\">class</span> StrBlob &#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">using</span> size_type = <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;::size_type;</div><div class=\"line\">\t\tStrBlob ();</div><div class=\"line\">\t\tStrBlob (<span class=\"built_in\">std</span>::initializeur_list&lt;<span class=\"built_in\">string</span>&gt; il);</div><div class=\"line\">\t\t<span class=\"function\">size_type <span class=\"title\">size</span> <span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span> <span class=\"params\">()</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">front</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">front</span> <span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">back</span><span class=\"params\">()</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">back</span> <span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">   </div><div class=\"line\">\t<span class=\"keyword\">private</span>:</div><div class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; data;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span> <span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">StrBlob:: StrBlob(): data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</div><div class=\"line\">StrBlob:: StrBlob(<span class=\"built_in\">std</span>::initializeur_list&lt;<span class=\"built_in\">string</span>&gt; il): data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</div><div class=\"line\">     </div><div class=\"line\"><span class=\"keyword\">void</span> StrBlob::check(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg) <span class=\"keyword\">const</span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (data-&gt;size() &lt;= i)</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> out_of_range (msg);</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">void</span> StrBlob::pop_back ()</div><div class=\"line\">&#123;</div><div class=\"line\">\tcheck(<span class=\"number\">0</span>,<span class=\"string\">\"pop_back on empty StrBlob\"</span>);</div><div class=\"line\">\tdata-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"built_in\">string</span>&amp; StrBlob::front() </div><div class=\"line\">&#123;</div><div class=\"line\">\t</div><div class=\"line\">\tcheck(<span class=\"number\">0</span>,<span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; StrBlob::front () <span class=\"keyword\">const</span></div><div class=\"line\">&#123;</div><div class=\"line\">  </div><div class=\"line\">\tcheck(<span class=\"number\">0</span>,<span class=\"string\">\"front on empty StrBlob\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;front();</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"built_in\">string</span>&amp; StrBlob::back()</div><div class=\"line\">&#123;</div><div class=\"line\">   \t</div><div class=\"line\">\tcheck(<span class=\"number\">0</span>,<span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; StrBlob::back() <span class=\"keyword\">const</span></div><div class=\"line\">&#123;</div><div class=\"line\">  \t</div><div class=\"line\">\tcheck(<span class=\"number\">0</span>,<span class=\"string\">\"back on empty StrBlob\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"练习12-3\"><a href=\"#练习12-3\" class=\"headerlink\" title=\"练习12.3\"></a><strong>练习12.3</strong></h3><blockquote>\n<p>StrBlob需要const版本的 push_back 和 pop_back 吗？如果需要，添加进去。否则，请解释。</p>\n</blockquote>\n<p>这道题挺有意思的。从语法角度来看加了const版本的push_back 和pop_back可以通过编译并没有出现错误。但是如果从类的使用者角度来考虑这个问题,加了它们会发生神奇的事情！<br>假设我们已经定义了const版本的 push_back 。然后我们 const StrBlob wtfBlob，定义了这么一个对象。接着我们使用push_back:<br>wtfBlob.push_back(lalala);</p>\n<p>从语法来看，wtfBlob是个指针常量，本身不能改变，指向的对象可以改变。而这里的push_back改变的是wtfBlob指向的对象，所以可以通过编译。<br>类的使用者并不知道StrBlob的实现细节，在他看来，wtfBlob就是一个容器。“一个const容器，竟然可以使用push_back,见鬼啦？”</p>\n<p>不加入const版本，用户写 wtfBlob.push_back(lalala); 不能通过编译，恰好能起到提醒的作用。所以不需要添加进去。</p>\n<h3 id=\"练习12-4\"><a href=\"#练习12-4\" class=\"headerlink\" title=\"练习12.4\"></a>练习12.4</h3><blockquote>\n<p>在 check 函数中，没有检查 i 是否大于０。为什么可以忽略这个检查？\n　　</p>\n</blockquote>\n<p>i 的类型是 size_type，任何小于0的实参将会被转化成大于０的数字,所以可以忽略这个检查。</p>\n<h3 id=\"练习12-5\"><a href=\"#练习12-5\" class=\"headerlink\" title=\"练习12.5\"></a>练习12.5</h3><blockquote>\n<p>我们未编写接受一个 initializer_list explicit 参数的构造函数。讨论这个设计策略的优点和缺点。</p>\n</blockquote>\n<p>如果我们编写了这样一个构造函数：<br><strong>优点</strong>:没有任何构造函数能隐式地创建StrBlob对象，代码将更清晰。<br><strong>缺点</strong>:总是需要构造临时的StrBlob对象。另外地，不能使用拷贝初始化。使用起来不方便</p>\n<h2 id=\"12-1-2节练习\"><a href=\"#12-1-2节练习\" class=\"headerlink\" title=\"12.1.2节练习\"></a>12.1.2节练习</h2><h3 id=\"练习12-6\"><a href=\"#练习12-6\" class=\"headerlink\" title=\"练习12.6\"></a>练习12.6</h3><blockquote>\n<p>编写函数，返回一个动态分配的 int 的 vector。将此 vector 传递给另一个函数，这个函数读取标准输入，将读入的值保存在 vector　元素中。再将 vector 传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。</p>\n</blockquote>\n<p>　　　<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>;\t\t<span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>; </div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec_make()</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &#123; &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; i) </div><div class=\"line\">\t\tiVec-&gt;push_back(i);</div><div class=\"line\">\t<span class=\"keyword\">return</span> iVec;\t</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : *iVec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cout</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">auto</span> vec = read(iVec_make());</div><div class=\"line\">\tprint(vec) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">delete</span> vec;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"练习12-7\"><a href=\"#练习12-7\" class=\"headerlink\" title=\"练习12.7\"></a>练习12.7</h3><blockquote>\n<p>重做上一题，这次使用 shared_ptr 而不是内置指针。</p>\n</blockquote>\n<p>　　　　　　<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>;\t\t<span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>; </div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec_make()</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ();</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; i) </div><div class=\"line\">\t\tiVec-&gt;push_back(i);</div><div class=\"line\">\t<span class=\"keyword\">return</span> iVec;\t</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;* iVec)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : *iVec)</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">cout</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">auto</span> vec = read( iVec_make() );</div><div class=\"line\">\tprint(vec) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"练习12-8\"><a href=\"#练习12-8\" class=\"headerlink\" title=\"练习12.8\"></a><strong><em>练习12.8</em></strong></h3><blockquote>\n<p>下面的函数是否有错误？如果有，解释错误原因。<br> bool b() {<br>     int *p = new int;<br>     // …<br>     return p;<br>}</p>\n</blockquote>\n<p>有错误。p由指针类型转换为布尔类型，程序没办法释放这片分配的动态内存。导致内存泄露问题。</p>\n<h3 id=\"练习12-9\"><a href=\"#练习12-9\" class=\"headerlink\" title=\"练习12.9\"></a>练习12.9</h3><blockquote>\n<p>解释下面代码执行的结果<br> int <em>q = new int(42), </em>r - new int(100);<br> r = q;<br> auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);<br> r2 = q2;</int></int></p>\n</blockquote>\n<ul>\n<li>q和r指向同一块动态分配的内存，没有指针指向另一块动态分配的内存，导致内存泄漏问题。</li>\n<li><strong><em>r2 = q2 </em></strong>使q2的引用计数递增为２，r2的引用计数递减为０。结果是之前给r2分配的内存自动地被释放。这代码是安全的。</li>\n</ul>\n<h2 id=\"12-1-3节练习\"><a href=\"#12-1-3节练习\" class=\"headerlink\" title=\"12.1.3节练习\"></a>12.1.3节练习</h2><h3 id=\"练习12-10\"><a href=\"#练习12-10\" class=\"headerlink\" title=\"练习12.10\"></a>练习12.10</h3><blockquote>\n<p>下面的代买调用了第413页定义的process函数，解释此调用是否正确。如果不正确，应如何修改?<br>    shared_ptr<int> p(new int(42));<br>    process(shared_ptr<int> (p));<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span> <span class=\"params\">(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; ptr)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"in process,ptr.use_count = \"</span> &lt;&lt; ptr.use_count() &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1 (<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span>));</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"before process,p1.use_count = \"</span> &lt;&lt; p1.use_count() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\tprocess (<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; (p1));</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after process,p1.use_count = \"</span> &lt;&lt; p1.use_count() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">   </div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></int></int></p>\n</blockquote>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">aphro@7559:~$ ./a</div><div class=\"line\">before process,p1.use_count = 1</div><div class=\"line\"><span class=\"keyword\">in</span> process,ptr.use_count = 2</div><div class=\"line\">after process,p1.use_count = 1</div></pre></td></tr></table></figure></p>\n<p>调用是正确的，创建临时对象<strong><em>shared_ptr<int> (p)</int></em></strong>处递增了p的引用计数。</p>\n<h3 id=\"练习12-11\"><a href=\"#练习12-11\" class=\"headerlink\" title=\"练习12.11\"></a>练习12.11</h3><blockquote>\n<p>如果我们像下面这样调用 process，会发生什么?<br> process (shared_ptr<int>(p.get()));</int></p>\n</blockquote>\n<p>p指向的内存在<strong><em>process()</em></strong>函数结束时被自动释放,再次使用p将发生未定义的行为。而且当p被销毁时，这块内存上发生<strong><em>double free</em></strong>。</p>\n<h3 id=\"练习12-12\"><a href=\"#练习12-12\" class=\"headerlink\" title=\"练习12.12\"></a><strong><em>练习12.12</em></strong></h3><blockquote>\n<p>p和sp的定义如下，对于接下来的对process的每个调用，如果合法，解释它做了什么，如果不合法，解释其错误原因：<br> auto p = new int();<br> auto sp = make_shared<int> ();</int></p>\n<ul>\n<li>process(sp);</li>\n<li>process(new int());</li>\n<li>process(p);</li>\n<li>process(shared_ptr<int> (p));</int></li>\n</ul>\n</blockquote>\n<ul>\n<li><p>合法，拷贝sp会递增其引用计数，在<strong><em>process</em></strong>中引用计数为2</p>\n</li>\n<li><p>不合法，接受指针参数的智能指针构造函数是explicit的。不能将一个内置指针隐式地转换为一个智能指针。</p>\n</li>\n<li><p>不合法，理由同２</p>\n</li>\n<li><p>虽然合法，但容易出问题，比如double free4. 虽然合法，但容易出问题，比如double free4. 虽然合法，但容易出问题，比如double free4. 虽然合法，但容易出问题，比如<strong><em>double free</em></strong>。</p>\n</li>\n</ul>\n<h3 id=\"练习12-13\"><a href=\"#练习12-13\" class=\"headerlink\" title=\"练习12.13\"></a>练习12.13</h3><blockquote>\n<p>如果执行下面的代码，会发生什么?<br> auto sp = make_shared<int> ();<br> auto p = sp.get();<br> delete p;</int></p>\n</blockquote>\n<p> 会发生<strong><em>double free</em></strong>。</p>\n"},{"title":"算法导论 第六章 堆排序","url":"http://eiwzz.github.io/2016/11/05/算法导论-第六章-堆排序/","content":"<blockquote>\n<p>堆排序的时间复杂度为O(nlgn),且具有空间原址性。它集合了插入排序和归并排序的优点。<br>堆排序引入了另一种算法设计技巧：使用“堆”这一数据结构来进行信息管理。</p>\n</blockquote>\n<h2 id=\"6-1-堆\"><a href=\"#6-1-堆\" class=\"headerlink\" title=\"6.1 堆\"></a>6.1 堆</h2><p><strong>(二叉)堆</strong>是一个数组，它可以被看成一个近似的完全二叉树，树上每个结点对应数组中的一个元素。除了最底层外，树是完全充满的，并且是从左至右填充。<br><a id=\"more\"></a><br>给定一个结点的下标i，可以计算出它的父结点、左孩子和右孩子的下标。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//PARENT(i)</span></div><div class=\"line\"><span class=\"keyword\">return</span> i/<span class=\"number\">2</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//LEFT(i)</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">2</span>i</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//RIGHT(i)</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">2</span>i+<span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p><img src=\"/img/dui.gif\" alt=\"dui\"></p>\n<p>二叉堆可分为最大堆和最小堆。<br><strong>最大堆性质</strong>: A[PARENT(i)] &gt;= A[i]<br><strong>最小堆性质</strong>: A[PARENT(i)] &lt;= A[i]</p>\n<p>堆中一个结点的<strong>高度</strong>为该结点到叶节点最长简单路径上边的数目。<br><strong>堆的高度</strong>定义为根结点的高度。<br>一个包含n个元素的堆，它的高度为⌊lgn⌋。</p>\n<p>一个堆排序算法有如下基本过程：<br><strong>MAX-HEAPIFY</strong>:时间复杂度为O(lgn),用来维护最大堆性质<br><strong>BUILD-MAX-HEAP</strong>:具有线性时间复杂度，从无序的输入数据数组中构造一个最大堆<br><strong>HEAPSORT</strong>:时间复杂度为O(nlgn),对一个数组进行原址排序</p>\n<h2 id=\"6-2-维护堆的性质\"><a href=\"#6-2-维护堆的性质\" class=\"headerlink\" title=\"6.2 维护堆的性质\"></a>6.2 维护堆的性质</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MAX-HEAPIFY(A,i)</span></div><div class=\"line\">l = LEFT(i)</div><div class=\"line\">r = RIGHT(i)</div><div class=\"line\"><span class=\"keyword\">if</span> l &lt;= A.heap-size and A[l] &gt; A[i]</div><div class=\"line\">\tlargest = l</div><div class=\"line\"><span class=\"keyword\">else</span> largest = i\t</div><div class=\"line\"><span class=\"keyword\">if</span> r &lt;= A.heap-size and A[r] &gt; A[largest]</div><div class=\"line\">\tlargest = r</div><div class=\"line\"><span class=\"keyword\">if</span> largest != i</div><div class=\"line\">\texchange A[i] with A[largest]</div><div class=\"line\">\tMAX-HEAPIFY(A,largest)       <span class=\"comment\">//交换数据后，以该结点为根的子树可能会违反最大堆的性质，因此递归调用MAX-HEAPIFY.</span></div></pre></td></tr></table></figure>\n<p><strong>MAX-HEAPIFY的时间代价</strong>：调整A[i]、A[LEFT(i)]和A[RIGHT(i)]的关系的时间代价Θ(1)和在一棵以i的一个孩子为根结点的子树上运行MAX-HEAPIFY的时间代价。<br>每个孩子的子树大小至多为2n/3(最坏情况为树的最底层恰好半满)<br>MAX-HEAPIFY的递归式为: T(n) &lt;= T(2n/3) + Θ(1)<br><strong>T(n) = O(lgn)</strong></p>\n<h2 id=\"6-3-建堆\"><a href=\"#6-3-建堆\" class=\"headerlink\" title=\"6.3 建堆\"></a>6.3 建堆</h2><p><strong>自底向上</strong>(练习题6.3-2解释为何要自底向上)利用MAX-HEAPIFY把数组转换为最大堆。子数组A(⌊n/2⌋+1..n)中的元素都是树的叶结点。每个叶结点都可以当作一个包含一个元素的堆。过程BUILD-MAXHEAP对树中其它的结点都调用一次MAX-HEAPIFY.<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//BUILD-MAXHEAP(A)</span></div><div class=\"line\"><span class=\"keyword\">for</span> i = A.heap-size/<span class=\"number\">2</span> to <span class=\"number\">1</span></div><div class=\"line\">\tMAX-HEAPIFY(A,i)</div></pre></td></tr></table></figure></p>\n<p>每次调用MAX-HEAPIFY的时间为O(lgn)，BUILD-MAXHEAP调用O(n)次，简单看时间复杂度为O(nlgn)。然而不同结点运行MAX-HEAPIFY的时间与该结点的树高相关。更紧确的时间复杂度为O(n)。</p>\n<p><img src=\"/img/buildheap.png\" alt=\"buildheap\"></p>\n<h2 id=\"6-4-堆排序算法\"><a href=\"#6-4-堆排序算法\" class=\"headerlink\" title=\"6.4 堆排序算法\"></a>6.4 堆排序算法</h2><p>利用BUILD-MAXHEAP将数组建成最大堆后，数组的最大元素总在A[1]上。把A[1]与A[n]交换后，最大堆性质可能被破坏,因此调用MAX-HEAPIFY(A,1)使A[1..n-1]构成最大堆。堆排序算法不断重复该过程。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//HEAPSORT(A)</span></div><div class=\"line\">BUILD-MAXHEAP(A)</div><div class=\"line\"><span class=\"keyword\">for</span> i = A.heap-size to <span class=\"number\">2</span></div><div class=\"line\">\texchange A[i] with A[<span class=\"number\">1</span>]</div><div class=\"line\">\tA.heap-size = A.heap-size - <span class=\"number\">1</span></div><div class=\"line\">\tMAX-HEAPIFY(A,<span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p><img src=\"/img/heapsort1.png\" alt=\"heapsort1\"><br><img src=\"/img/heapsort2.png\" alt=\"heapsort2\"></p>\n<p>调用BUILD-MAXHEAP的时间为O(n), n-1次调用时间复杂度为O(lgn)的MAX-HEAPIFY。因此HEAPSORT的时间复杂度为O(nlgn)。</p>\n<p><strong>heapsort算法C++代码实现：</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//注意数组下标</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">LEFT</span><span class=\"params\">(i)</span> </span>&#123; <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">1</span>; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">RIGHT</span><span class=\"params\">(i)</span> </span>&#123; <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">2</span>; &#125;\t</div><div class=\"line\">  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxHeapfiy</span> <span class=\"params\">(<span class=\"keyword\">double</span> *A, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> heapSize)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> l = LEFT(i);</div><div class=\"line\">\t<span class=\"keyword\">int</span> r = RIGHT(i);</div><div class=\"line\">\t<span class=\"keyword\">int</span> largest;</div><div class=\"line\">\t<span class=\"keyword\">double</span> tmp;</div><div class=\"line\">  </div><div class=\"line\">\t<span class=\"keyword\">if</span> (l &lt; heapsize and A[l] &gt; A[i])</div><div class=\"line\">\t\tlargest = l;</div><div class=\"line\">\t<span class=\"keyword\">else</span> </div><div class=\"line\">\t\tlargest = i;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (r &lt; heapsize and A[r] &gt; A[largest])</div><div class=\"line\">\t\tlargest = r;</div><div class=\"line\">  </div><div class=\"line\">\t<span class=\"keyword\">if</span> (largest != i)&#123;</div><div class=\"line\">\t\ttmp = A[i];</div><div class=\"line\">\t\tA[i] = A[largest];</div><div class=\"line\">\t\tA[largest] = tmp;</div><div class=\"line\">  </div><div class=\"line\">\t\tmaxHeapfiy(A,largest,heapSize);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildMaxHeap</span> <span class=\"params\">(<span class=\"keyword\">double</span> *A, <span class=\"keyword\">int</span> heapSize)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = heapsize/<span class=\"number\">2</span><span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; i--)</div><div class=\"line\">\t\tmaxHeapfiy(A,i,heapSize);</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heapSort</span> <span class=\"params\">(<span class=\"keyword\">double</span> *A, <span class=\"keyword\">int</span> heapSize)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tbuildMaxHeap(A,heapSize);</div><div class=\"line\">\t<span class=\"keyword\">double</span> tmp;</div><div class=\"line\">  </div><div class=\"line\">\t<span class=\"keyword\">for</span> (i = heapSize<span class=\"number\">-1</span>; i != <span class=\"number\">0</span>; i--)&#123;</div><div class=\"line\">\t\ttmp = A[i];</div><div class=\"line\">\t\tA[i] = A[<span class=\"number\">0</span>];</div><div class=\"line\">\t\tA[<span class=\"number\">0</span>] = A[i];</div><div class=\"line\">\t\theapSize--;</div><div class=\"line\">\t\tmaxHeapfiy(A,<span class=\"number\">0</span>,heapSize);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"算法导论 第二章 算法基础","url":"http://eiwzz.github.io/2016/11/03/算法导论-第二章-算法基础/","content":"<blockquote>\n<p>只为巩固知识，不保证完全正确.</p>\n</blockquote>\n<h2 id=\"2-1-插入排序\"><a href=\"#2-1-插入排序\" class=\"headerlink\" title=\"2.1 插入排序\"></a>2.1 插入排序</h2><p><strong>基本思想</strong><br>每步将一个待排序的对象,按其排序码大小,插入到前面已经排好序的一组对象的适当位置上,直到对象全部插入为止。(类似于排序手上的扑克牌)<br><a id=\"more\"></a><br><img src=\"/img/insertSorteg.gif\" alt=\"insertSort\"></p>\n<p><strong>时间复杂度</strong><br>最差时间复杂度：O(n^2)<br>最优时间复杂度：O(n)</p>\n<p><strong>伪代码</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//INSERTION-SORT(A)</div><div class=\"line\">for j = 2 to A.length</div><div class=\"line\">\tkey = A[j]</div><div class=\"line\">\ti = j - 1</div><div class=\"line\">\twhile i &gt; 0 and key &lt; A[i]</div><div class=\"line\">\t\tA[i+1] = A[i]</div><div class=\"line\">\t\ti = i - 1</div><div class=\"line\">\tA[i+1] = key</div></pre></td></tr></table></figure></p>\n<p><strong>C++代码</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span> <span class=\"params\">(<span class=\"keyword\">double</span> *a, <span class=\"keyword\">int</span> length)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span> key;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>, i; j != length; j++)&#123;</div><div class=\"line\">\t\tkey = a[j];</div><div class=\"line\">\t\ti = j - <span class=\"number\">1</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; key &lt; a[i])&#123;</div><div class=\"line\">\t\t\ta[i+<span class=\"number\">1</span>] = a[i];</div><div class=\"line\">\t\t\ti--;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ta[i+<span class=\"number\">1</span>] = key;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"练习题\"><a href=\"#练习题\" class=\"headerlink\" title=\"练习题\"></a>练习题</h3><p><strong>2.1-1</strong><br><img src=\"/img/2_1-1.png\" alt=\"2.1-1\"></p>\n<p><strong>2.1-2</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//INSERTION-SORT(A)</span></div><div class=\"line\"><span class=\"keyword\">for</span> j = <span class=\"number\">2</span> to A.length</div><div class=\"line\">\tkey = A[j]</div><div class=\"line\">\ti = j - <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> i &gt; <span class=\"number\">0</span> and key &gt; A[i]</div><div class=\"line\">\t\tA[i+<span class=\"number\">1</span>] = A[i]</div><div class=\"line\">\t\ti = i - <span class=\"number\">1</span></div><div class=\"line\">\tA[i+<span class=\"number\">1</span>] = key</div></pre></td></tr></table></figure></p>\n<p><strong>2.1-4</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//BINARY-ADD(A,B,C)</span></div><div class=\"line\">flag = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span> to n</div><div class=\"line\">\tkey = A[i] + B[i] + flag</div><div class=\"line\">\tC[i] = key mod <span class=\"number\">2</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> key &gt; <span class=\"number\">1</span></div><div class=\"line\">\tflag = <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> flag = <span class=\"number\">0</span></div><div class=\"line\">C[n+<span class=\"number\">1</span>] = flag</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-分析算法\"><a href=\"#2-2-分析算法\" class=\"headerlink\" title=\"2.2 分析算法\"></a>2.2 分析算法</h2><h3 id=\"练习题-1\"><a href=\"#练习题-1\" class=\"headerlink\" title=\"练习题\"></a>练习题</h3><p><strong>2.2-1</strong><br>n^3/1000 - 100n^2 - 100n + 3 = Θ(n^3)</p>\n<p><strong>2.2-2</strong><br>选择排序伪代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> j = <span class=\"number\">1</span> to A.length<span class=\"number\">-1</span> </div><div class=\"line\">\tmin = j</div><div class=\"line\">\ti = j + <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> i &lt;= length</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (A[min] &gt; A[i])</div><div class=\"line\">\t\tmin = i</div><div class=\"line\">\t    i = i + <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> min != j</div><div class=\"line\">\t\ttmp = A[j]</div><div class=\"line\">\t\tA[j] = A[min]</div><div class=\"line\">\t\tA[min] = tmp</div></pre></td></tr></table></figure></p>\n<p>最好情况和最坏情况都为Θ(n^2)</p>\n<p><strong>2.2-3</strong><br>由于要查找的元素等可能的为数组中任意元素，则平均需要检查输入序列的一半元素。最坏即最后一个元素为待查元素。最好和最坏运行情况都为Θ(n).</p>\n<p><strong>2.2-4</strong><br>对输入进行控制?</p>\n<h2 id=\"2-3-设计算法\"><a href=\"#2-3-设计算法\" class=\"headerlink\" title=\"2.3 设计算法\"></a>2.3 设计算法</h2><p>算法设计技术有很多。插入排序使用了增量方法：即在已排序好的子数组A[1…i-1]中将单个元素A[i]插入子数组的适当位置<br>下面是分治法，将原问题分解为规模较小但类似于原问题的子问题，递归求解这些子问题，然后合并子问题的解。</p>\n<h3 id=\"2-3-1-分治法\"><a href=\"#2-3-1-分治法\" class=\"headerlink\" title=\"2.3.1 分治法\"></a>2.3.1 分治法</h3><p>分治法在每层递归时分为三个步骤：<br><strong>分解</strong>原问题为若干子问题，子问题是原问题更小的实例.<br><strong>解决</strong>这些子问题，递归求解各子问题。当子问题规模足够小，直接求解.(需要提供递归停止的条件)<br><strong>合并</strong>这些子问题的解，即原问题的解</p>\n<p>下面介绍<strong>归并排序</strong><br><strong>分解</strong>：分解n个元素的序列成两个n/2的子序列。<br><strong>解决</strong>: 归并排序这两个子序列。<br><strong>合并</strong>：合并两个已排序好的子序列产生规模更大的已排序子序列<br>归并排序的关键操作是合并两个已排序好的序列。通过调用辅助过程MERGE来完成合并。<br><img src=\"/img/mergeSorteg.png\" alt=\"mergeSort\"></p>\n<p>虽然我们描述的是先分解后合并,但是该实际过程是一边分解一边归并，前半部分排好后排后半部分。整个过程按红色编号的顺序执行。</p>\n<p>CLRS提供的MERGE伪代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MERGE(A,p,q,r)</span></div><div class=\"line\">n1 = q - p + <span class=\"number\">1</span></div><div class=\"line\">n2 = r - q</div><div class=\"line\">let L[<span class=\"number\">1.</span>.n1+<span class=\"number\">1</span>] and R[<span class=\"number\">1.</span>.n2+<span class=\"number\">1</span>] be <span class=\"keyword\">new</span> arrays</div><div class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span> to n1</div><div class=\"line\">\tL[i] = A[p+i<span class=\"number\">-1</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> j = <span class=\"number\">1</span> to n2</div><div class=\"line\">\tR[j] = A[q+j]</div><div class=\"line\">L[n1+<span class=\"number\">1</span>] = R[n2+<span class=\"number\">1</span>] = ∞\t</div><div class=\"line\">i = j = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span> k = p to r</div><div class=\"line\">\t<span class=\"keyword\">if</span> L[i] &lt;= R[j]</div><div class=\"line\">\t\tA[k] = L[i]</div><div class=\"line\">\t\ti = i + <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\tA[k] = R[j]</div><div class=\"line\">\t\tj = j + <span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<p>我根据练习<strong>2.3-2</strong>写的MERGE伪代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MERGE(A,B,p,q,r)</span></div><div class=\"line\">i = p</div><div class=\"line\">j = q + <span class=\"number\">1</span></div><div class=\"line\">k = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">while</span> (i &lt;= q and j &lt;= r)</div><div class=\"line\">\t<span class=\"keyword\">if</span> (A[i] &lt;= A[j])</div><div class=\"line\">\t\tB[k++] = A[i++]</div><div class=\"line\">\t<span class=\"keyword\">else</span> B[k++] = a[j++]\t</div><div class=\"line\"><span class=\"keyword\">while</span> (i &lt;= q)</div><div class=\"line\">\tB[k++] = A[i++]</div><div class=\"line\"><span class=\"keyword\">while</span> (j &lt;= r)</div><div class=\"line\">\tB[k++] = A[j++]</div><div class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span> to k<span class=\"number\">-1</span> </div><div class=\"line\">\tA[p+i<span class=\"number\">-1</span>] = B[k]</div></pre></td></tr></table></figure></p>\n<p>现在可以把过程MERGE作为归并排序算法的子程序来用。MERGE-SORT(A,p,r)将排序数组A[p…r]中的元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MERGE-SORT(A,p,r)</span></div><div class=\"line\"><span class=\"keyword\">if</span> p &lt; r</div><div class=\"line\">\tq = (p+r)/<span class=\"number\">2</span></div><div class=\"line\">\tMERGE-SORT(A,p,q)</div><div class=\"line\">\tMERGE-SORT(A,q+<span class=\"number\">1</span>,r)</div><div class=\"line\">\tMERGE(A,p,q,r)</div></pre></td></tr></table></figure>\n<p><strong>归并排序C++代码实现：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span> <span class=\"params\">(<span class=\"keyword\">double</span> a[], <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> last, <span class=\"keyword\">double</span> tmp[])</span> <span class=\"comment\">//合并有序数组</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = first, j = mid + <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= last) &#123;     <span class=\"comment\">//一旦某一边的所有元素均被复制回tmp数组则立刻停止</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i] &lt;= a[j])</div><div class=\"line\">\t\t\t\ttmp[k++] = a[i++];</div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t\t\ttmp[k++] = a[j++];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid)                   <span class=\"comment\">//把数组另一边的剩余元素复制给tmp数组</span></div><div class=\"line\">\t\ttmp[k++] = a[i++];</div><div class=\"line\">\t<span class=\"keyword\">while</span> (j &lt;= last)</div><div class=\"line\">\t\ttmp[k++] = a[j++];</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; k; i++)</div><div class=\"line\">\t\ta[first+i] = tmp[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergesort</span> <span class=\"params\">(<span class=\"keyword\">double</span> a[], <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last, <span class=\"keyword\">double</span> tmp[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (first &lt; last)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> mid = (first + last) / <span class=\"number\">2</span>;</div><div class=\"line\">\t\t\tmergesort (a,first,mid,tmp);  <span class=\"comment\">//左边排序</span></div><div class=\"line\">\t\t\tmergesort (a,mid+<span class=\"number\">1</span>,last,tmp); <span class=\"comment\">//右边排序</span></div><div class=\"line\">\t\t\tmerge(a,first,mid,last,tmp);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">MergeSort</span> <span class=\"params\">(<span class=\"keyword\">double</span> a[], <span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span>  *p = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[n]; \t<span class=\"comment\">//创建一个数组用来交换元素</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\tmergesort(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,p);</div><div class=\"line\">\t<span class=\"keyword\">delete</span>[] p;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>归并排序在最坏情况下的运行时间为Θ(nlgn).高效但耗用较大空间资源.</p>\n<h3 id=\"练习题-2\"><a href=\"#练习题-2\" class=\"headerlink\" title=\"练习题\"></a>练习题</h3><p><strong>2.2-2</strong> 上面第二个MERGE版本</p>\n<p><strong>2.3-3</strong><br>n = 2时，T(2) = 2lg2 = 2 符合条件<br>设 n = 2^k 时，T(2^k) = 2^klg2k 成立<br>则当 n = 2^(k+1)时，T(2^(k+1)) = 2T(2^(k+1)/2) + 2^(k+1) = 2T(2^k) + 2^(k+1) = 2^(k+1)lg2^(k+1)</p>\n<p><strong>2.3-4</strong><br><img src=\"/img/2_3-4.gif\" alt=\"2.3-4\"></p>\n<p><strong>2.3-5</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//BINARY-SEARCH(A,p,r,v)</span></div><div class=\"line\"><span class=\"keyword\">if</span> p &lt;= r</div><div class=\"line\">\tq = (p+r)/<span class=\"number\">2</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> A[q]=v</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> q</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> A[q] &gt; v</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> BINARY-SEARCH(A,p,q<span class=\"number\">-1</span>,v)</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> BINARY-SORT(A,q+<span class=\"number\">1</span>,r,v)</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span></div></pre></td></tr></table></figure></p>\n<p>二分查找的递归式为：<br><img src=\"/img/2_3-5.jpg\" alt=\"2.3-5\"></p>\n<p>最坏运行时间为Θ(lgn)</p>\n<p><strong>2.3-6</strong><br>不能。最坏情况总运行时间为Θ(n^2)。</p>\n"},{"title":"Linux升级内核/boot空间不足解决办法","url":"http://eiwzz.github.io/2016/11/03/Linux升级内核-boot空间不足解决办法/","content":"<blockquote>\n<p>今天安装更新时，系统提示我/boot空间已满。内核文件默认储存在/boot中，多次升级内核后，内核版本太多，清理没有的内核文件就行。</p>\n</blockquote>\n<h2 id=\"首先看一下磁盘情况：\"><a href=\"#首先看一下磁盘情况：\" class=\"headerlink\" title=\"首先看一下磁盘情况：\"></a>首先看一下磁盘情况：</h2><p>输入　df -h<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ df -h</div><div class=\"line\">文件系统        容量  已用  可用 已用% 挂载点</div><div class=\"line\">udev            3.9G     0  3.9G    0% /dev</div><div class=\"line\">tmpfs           786M  9.6M  777M    2% /run</div><div class=\"line\">/dev/sda6        29G  6.9G   20G   26% /</div><div class=\"line\">tmpfs           3.9G  221M  3.7G    6% /dev/shm</div><div class=\"line\">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</div><div class=\"line\">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</div><div class=\"line\">/dev/sda8       181M  172M     0  100% /boot</div><div class=\"line\">/dev/sda9       260G   22G  225G    9% /home</div><div class=\"line\">/dev/sda1        96M   29M   68M   30% /boot/efi</div><div class=\"line\">tmpfs           786M   64K  786M    1% /run/user/1000</div></pre></td></tr></table></figure></p>\n<p>/boot已用100％需要清理了。<br><a id=\"more\"></a></p>\n<h2 id=\"查看当前使用的内核版本号。\"><a href=\"#查看当前使用的内核版本号。\" class=\"headerlink\" title=\"查看当前使用的内核版本号。\"></a>查看当前使用的内核版本号。</h2><p>输入　uname -a<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ uname <span class=\"_\">-a</span></div><div class=\"line\">Linux 7559 4.4.0-38-generic <span class=\"comment\">#57-Ubuntu SMP Tue Sep 6 15:42:33 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></div></pre></td></tr></table></figure></p>\n<p>当前内核版本号<em>4.4.0-38</em></p>\n<h2 id=\"删除旧内核\"><a href=\"#删除旧内核\" class=\"headerlink\" title=\"删除旧内核\"></a>删除旧内核</h2><p>输入　sudo apt-get remove linux-image- 　接着按两下空格将显示当前储存的所有内核版本，把之前的版本删除就行。<strong>刚升级的版本可能不稳定，为了保险保留之前1-2版本备用。</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get remove linux-image-</div><div class=\"line\">linux-image-4.4.0-36-generic        linux-image-extra-4.4.0-36-generic</div><div class=\"line\">linux-image-4.4.0-38-generic        linux-image-extra-4.4.0-38-generic</div><div class=\"line\">linux-image-4.4.0-45-generic        linux-image-generic</div><div class=\"line\">aphro@7559:~$ sudo apt-get remove linux-image-4.4.0-36-generic </div><div class=\"line\">[sudo] aphro 的密码： </div><div class=\"line\">正在读取软件包列表... 完成</div><div class=\"line\">正在分析软件包的依赖关系树       </div><div class=\"line\">正在读取状态信息... 完成       </div><div class=\"line\">下列软件包是自动安装的并且现在不需要了：</div><div class=\"line\">  linux-headers-4.4.0-36 linux-headers-4.4.0-36-generic</div><div class=\"line\">  使用<span class=\"string\">'sudo apt autoremove'</span>来卸载它(它们)。</div><div class=\"line\">  下列软件包将被【卸载】：</div><div class=\"line\">   linux-image-4.4.0-36-generic linux-image-extra-4.4.0-36-generic</div><div class=\"line\">   linux-signed-image-4.4.0-36-generic</div><div class=\"line\">   升级了 0 个软件包，新安装了 0 个软件包，要卸载 3 个软件包，有 136 个软件包未被升级。</div><div class=\"line\">   有 5 个软件包没有被完全安装或卸载。</div><div class=\"line\">   解压缩后将会空出 218 MB 的空间。</div><div class=\"line\">   您希望继续执行吗？ [Y/n] Y</div></pre></td></tr></table></figure></p>\n<h2 id=\"再次查看-boot分区容量\"><a href=\"#再次查看-boot分区容量\" class=\"headerlink\" title=\"再次查看/boot分区容量\"></a>再次查看/boot分区容量</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ df -h</div><div class=\"line\">文件系统        容量  已用  可用 已用% 挂载点</div><div class=\"line\">udev            3.9G     0  3.9G    0% /dev</div><div class=\"line\">tmpfs           786M  9.6M  777M    2% /run</div><div class=\"line\">/dev/sda6        29G  6.6G   21G   25% /</div><div class=\"line\">tmpfs           3.9G  243M  3.6G    7% /dev/shm</div><div class=\"line\">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</div><div class=\"line\">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</div><div class=\"line\">/dev/sda8       181M  119M   49M   71% /boot</div><div class=\"line\">/dev/sda9       260G   22G  225G    9% /home</div><div class=\"line\">/dev/sda1        96M   29M   68M   30% /boot/efi</div><div class=\"line\">tmpfs           786M   64K  786M    1% /run/user/1000</div></pre></td></tr></table></figure>\n"},{"title":"about","url":"http://eiwzz.github.io/about/index.html","content":""},{"title":"search","url":"http://eiwzz.github.io/search/index.html","content":""},{"title":"tag","url":"http://eiwzz.github.io/tag/index.html","content":""}]